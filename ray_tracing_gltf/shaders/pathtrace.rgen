#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_shader_clock : enable


#include "binding.glsl"
#include "raycommon.glsl"
#include "sampling.glsl"

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1, rgba32f) uniform image2D image;

layout(location = 0) rayPayloadEXT hitPayload prd;

layout(set = 1, binding = B_CAMERA) uniform CameraProperties
{
  mat4 view;
  mat4 proj;
  mat4 viewInverse;
  mat4 projInverse;
}
cam;

layout(push_constant) uniform Constants
{
  vec4  clearColor;
  vec3  lightPosition;
  float lightIntensity;
  int   lightType;
  int   frame;
  int   maxBounces;
  int   firstBounce;
  int   renderFlags;
}
pushC;

float D_GGX(float ndh, float roughness) {
    float a = ndh * roughness;
    float k = roughness / max(1e-4, 1.0 - ndh * ndh + a * a);
    return k * k * (1.0 / M_PI);
}

float V_SmithGGXCorrelatedFast(float ndv, float ndl, float roughness) {
    float a = roughness;
    float GGXV = ndv * (ndv * (1.0 - a) + a);
    float GGXL = ndl * (ndl * (1.0 - a) + a);
    return 0.5 / (GGXV + GGXL);
}

vec3 F_Schlick(float u, vec3 f0) {
    return f0 + (vec3(1.0) - f0) * pow(1.0 - u, 5.0);
}

void main()
{
  // Initialize the random number
  uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int(clockARB()));

  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2       d           = inUV * 2.0 - 1.0;

  vec4 origin    = cam.viewInverse * vec4(0, 0, 0, 1);
  vec4 target    = cam.projInverse * vec4(d.x, d.y, 1, 1);
  vec4 direction = cam.viewInverse * vec4(normalize(target.xyz), 0);

  uint  rayFlags = gl_RayFlagsOpaqueEXT;
  float tMin     = 0.001;
  float tMax     = 10000.0;

  vec3 lightModulation = vec3(1);
  vec3 rayAccumLight = vec3(0);

  for(int rayDepth = 0; rayDepth < pushC.maxBounces+1; rayDepth++)
  {
    traceRayEXT(topLevelAS,        // acceleration structure
                rayFlags,          // rayFlags
                0xFF,              // cullMask
                0,                 // sbtRecordOffset
                0,                 // sbtRecordStride
                0,                 // missIndex
                origin.xyz,            // ray origin
                tMin,              // ray min range
                direction.xyz,         // ray direction
                tMax,              // ray max range
                0                  // payload (location = 0)
    );

    if(rayDepth >= pushC.firstBounce ||
      (rayDepth == 0 && prd.world_position.w < 0)) // Always show the background
    {
      rayAccumLight += lightModulation * prd.emittance;
    }
    if(prd.world_position.w < 0) // miss
    {
      break;
    }

    vec3 scatterDirection;

    // Reconstruct PBR material
    vec3 specularColor = mix(vec3(0.04), prd.baseColor.xyz, prd.metallic);
    vec3 diffuseColor = prd.baseColor.xyz * (1.0-prd.metallic);
    //diffuseColor = vec3(0.85);

    // 50% probability for each path
    if((seed & 1) > 0) // Diffuse
    {
      if(rayDepth == 0 && (pushC.renderFlags & FLAG_SPECULAR_ONLY) > 0)
        break; // Ignore diffuse path

      // Scatter ray direction
      if((pushC.renderFlags & FLAG_IMPORTANCE_SAMPLING) > 0) // Importance sampling
      {
        vec2 seed2 = vec2(rnd(seed), rnd(seed));
        scatterDirection = normalize(randomUnitVector(seed2)*0.999 + prd.world_normal);
        const float ndl = max(0.0, dot(scatterDirection, prd.world_normal));
        // 2 factor to compensate for 50% probability of hitting this light path
        lightModulation *= 2.0 * diffuseColor / M_PI;
      }
      else // Uniform sampling
      {
        vec3 tangent, bitangent;
        createCoordinateSystem(prd.world_normal, tangent, bitangent);
        scatterDirection = samplingHemisphere(seed, tangent, bitangent, prd.world_normal);
        const float ndl = max(0.0, dot(scatterDirection, prd.world_normal));
        // 2 factor to compensate for 50% probability of hitting this light path
        lightModulation *= 2.0 * ndl * diffuseColor / M_PI;
      }
    }
    else // Specular
    {
      if(rayDepth == 0 && (pushC.renderFlags & FLAG_DIFFUSE_ONLY) > 0)
        break; // Ignore specular path

      // Scatter ray direction
      vec3 tangent, bitangent;
      createCoordinateSystem(prd.world_normal, tangent, bitangent);
      scatterDirection = samplingHemisphere(seed, tangent, bitangent, prd.world_normal);

      vec3 halfVector = normalize(scatterDirection - direction.xyz);
      const float alpha = prd.roughness * prd.roughness;
      const float ndl = max(0.0, dot(scatterDirection, prd.world_normal));
      const float ndh = max(0.0, dot(halfVector, prd.world_normal));
      const float hdl = max(0.0, dot(halfVector, scatterDirection));
      const float ndv = max(0.0, -dot(direction.xyz, prd.world_normal));
      float D = D_GGX(ndh, alpha);
      float V = V_SmithGGXCorrelatedFast(ndv, ndl, prd.roughness);
      vec3 F = F_Schlick(hdl, specularColor);
      vec3 Fr = (D*V)*F;

      // 2 factor to compensate for 50% probability of hitting this light path
      lightModulation *= 2.0 * Fr;
    }

    // new ray config
    origin = vec4(prd.world_position.xyz, 1.0);
    direction = vec4(scatterDirection, 0.0);
  }

  // Do accumulation over time
  if(pushC.frame > 0)
  {
    float a         = 1.0f / float(pushC.frame + 1);
    vec3  old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color, rayAccumLight, a), 1.f));
  }
  else
  {
    // First frame, replace the value in the buffer
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(rayAccumLight, 1.f));
  }
}
