#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_shader_clock : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "binding.glsl"
#include "gltf.glsl"
#include "raycommon.glsl"
#include "sampling.glsl"

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1, rgba32f) uniform image2D image;
layout(set = 0, binding = 2) readonly buffer _InstanceInfo {PrimMeshInfo primInfo[];};

// For light sampling
layout(set = 1, binding = B_MATRICES) readonly buffer _Matrix { mat4 matrices[]; };
layout(set = 1, binding = B_LIGHT_INST) readonly buffer _LightInstance { LightInstanceInfo lightIstances[]; };
layout(set = 1, binding = B_LIGHT_TRIS) readonly buffer _EmissiveTriangle { EmissiveTriangleInfo emissiveTriangles[]; };
layout(set = 1, binding = B_TRI_ALIAS) readonly buffer _TriangleAlias { AliasTable triangleAlias[]; };
layout(set = 1, binding = B_LIGHT_ALIAS) readonly buffer _LightAlias { AliasTable lightAlias[]; };
layout(set = 1, binding = B_VERTICES) readonly buffer _VertexBuf {float vertices[];};
layout(set = 1, binding = B_INDICES) readonly buffer _Indices {uint indices[];};

layout(location = 0) rayPayloadEXT hitPayload prd;

layout(set = 1, binding = B_CAMERA) uniform CameraProperties
{
  mat4 view;
  mat4 proj;
  mat4 viewInverse;
  mat4 projInverse;
}
cam;

layout(push_constant) uniform Constants
{
    uint renderFlags;
    vec4  clearColor;
    int   frame;
    float lensRadius;
    float focalDistance;
    int maxBounces;
    int firstBounce;
    int numLightInstances;
    uint numEmissiveTriangles;
	int numPathsPerPixel;
	int numGeomSamplesM;
	int numTrianglesM;
}
pushC;

bool renderFlag(uint flag)
{
	return (pushC.renderFlags & flag) > 0;
}

float D_GGX(float ndh, float a) {
    float k = a / max(1e-4, (ndh * ndh)*(a*a-1) + 1);
    return k * k / M_PI;
}

// Earl Hammon's Diffuse GGX talk
// Predivided by 4*ndl*ndv
float SmithGGX_G2Approx(float ndv, float ndl, float a)
{
    return 0.5 / mix(2*ndl*ndv, ndl+ndv, a);
}

// Actually returns G1/(2NdV) as it cancels out some terms in the VNDF estimator
float SmithGGXG1(float ndv, float alpha)
{
	float a2 = alpha*alpha;
	float num = 2*ndv;
	float den = ndv + sqrt(a2 + (1-a2)*ndv*ndv);
	return num / max(den,1e-6);
}

float SmithGGX_G2_over_G1(float ndv, float ndl, float alpha)
{
	float a2 = alpha*alpha;
	float den = ndv + sqrt(a2+(1-a2)*ndv*ndv);
	return den * 0.5 / mix(2*ndl*ndv, ndl+ndv, alpha);
}

vec3 F_Schlick(float hdl, vec3 f0) {
    float p = (1-hdl);
    float p2 = p*p;
    float p5 = p*p2*p2;
    return f0 + (1.0 - f0) * p5;
}

bool traceRay(in vec3 ro, in vec3 rd)
{
    uint  rayFlags = gl_RayFlagsOpaqueEXT;
    float tMax     = 10000.0;

  traceRayEXT(topLevelAS, // acceleration structure
        rayFlags,       // rayFlags
        0xFF,           // cullMask
        0,              // sbtRecordOffset
        0,              // sbtRecordStride
        0,              // missIndex
        ro,             // ray origin
        0.0,           // ray min range
        rd,           // ray direction
        tMax,           // ray max range
        0               // payload (location = 0)
      );

    return prd.worldPos.w >= 0;
}

bool traceRay(in vec3 ro, in vec3 rd, float maxT)
{
    uint  rayFlags = gl_RayFlagsOpaqueEXT;

  traceRayEXT(topLevelAS, // acceleration structure
        rayFlags,       // rayFlags
        0xFF,           // cullMask
        0,              // sbtRecordOffset
        0,              // sbtRecordStride
        0,              // missIndex
        ro,             // ray origin
        0.0,           // ray min range
        rd,           // ray direction
        maxT,           // ray max range
        0               // payload (location = 0)
      );

    return prd.worldPos.w >= 0;
}

// Return the vertex position
vec3 getVertex(uint index)
{
  vec3 vp;
  vp.x = vertices[3 * index + 0];
  vp.y = vertices[3 * index + 1];
  vp.z = vertices[3 * index + 2];
  return vp;
}

// No dot(n,l) included
vec3 brdfModulation(in vec3 normal, in vec3 eye, in vec3 light, in vec3 diff, in vec3 spec, float roughness)
{
	vec3 H = normalize(eye+light);
	float hdl = max(0,dot(H,light));
	float alpha = roughness*roughness;
	float ndl = max(0,dot(normal, light));
	float D = D_GGX(ndl, alpha);
	float ndv = max(0,dot(eye,normal));
	float V = SmithGGX_G2Approx(ndv, ndl, alpha);

	vec3 kS = F_Schlick(hdl, spec) * D * V;
	vec3 kD = diff / M_PI; // TODO: Proper energy conservation
	if(renderFlag(FLAG_NO_DIFF))
		kD = vec3(0);
	return kD + kS;
}

EmissiveTriangleInfo sampleTwoLevelLight(inout uint seed, in vec3 origin, out float invPdf)
{
	EmissiveTriangleInfo result;

	// Choose an emissive mesh
	uint nLights = pushC.numLightInstances;
	uint emitterIndex;
	LightInstanceInfo lightInfo;
	float accumReservoirWeight = 0;
	float sampleWeight = 0;
	float reservoirProb = 0;
	if(renderFlag(FLAG_USE_ALIAS))
	{
		for(int i = 0; i < pushC.numGeomSamplesM; ++i)
		{
			// Choose an alias
			float r = rnd(seed)*nLights;
			uint bucket = uint(r);
			float p = r-bucket;
			AliasTable alias = lightAlias[nonuniformEXT(bucket)];
			uint emitterIndex = (p>alias.cutoff) ? alias.Ki : bucket;

			LightInstanceInfo candidate = lightIstances[nonuniformEXT(emitterIndex)];
			reservoirProb += candidate.weightedRadiance;

			// Candidate matrix
			mat4 worldFromCandidate = matrices[candidate.matrixIndex];
			vec3 meanPos = (worldFromCandidate*vec4(0,0,0,1)).xyz;
			float dist2 = dot(meanPos-origin, meanPos-origin);
			float w = 1 / dist2;
			accumReservoirWeight += w;
			if(rnd(seed) < w/accumReservoirWeight)
			{
				lightInfo = candidate;
				sampleWeight = w;
			}
		}

		invPdf = accumReservoirWeight / (sampleWeight);
	}
	else
	{
		emitterIndex = lcg(seed) % nLights;
		lightInfo = lightIstances[nonuniformEXT(emitterIndex)];
		invPdf = nLights * lightInfo.numTriangles;
	}

	// Retrieve the Primitive mesh buffer information
	uint triNdx = lcg(seed) % lightInfo.numTriangles;

	// Getting the 'first index' for this mesh (offset of the mesh + offset of the triangle)
	result.indexOffset = lightInfo.indexOffset + (3 * triNdx);
	result.vtxOffset = lightInfo.vtxOffset;           // Vertex offset as defined in glTF
	result.matrixIndex = lightInfo.matrixIndex;

	return result;
}

EmissiveTriangleInfo sampleTriangleWithAliasTable(inout uint seed)
{
	uint nLights = pushC.numEmissiveTriangles;
	// Choose an alias
	//float r = rnd(seed)*nLights;
	lcg(seed);
	uint bucket = seed % nLights;//uint(r);
	float p = rnd(seed);//r-bucket;
	AliasTable alias = triangleAlias[nonuniformEXT(bucket)];
	uint emitterIndex = (p>alias.cutoff) ? alias.Ki : bucket;
	return emissiveTriangles[emitterIndex];
}

EmissiveTriangleInfo sampleEmissiveTris(inout uint seed, out float invPdf)
{
	EmissiveTriangleInfo result;

	uint nLights = pushC.numEmissiveTriangles;
	if(renderFlag(FLAG_USE_ALIAS))
	{
		result = sampleTriangleWithAliasTable(seed);
		invPdf = 1.f / result.weightedRadiance;
	}
	else
	{
		// Choose an emissive triangle
		invPdf = nLights;
		uint emitterIndex = lcg(seed) % nLights;
		result = emissiveTriangles[emitterIndex];
		invPdf = 1 / nLights;
	}

	return result;
}

void uniformSampleTriangle(inout uint seed, in EmissiveTriangleInfo triangle, out vec3 x, out vec3 normal, out float triangleArea)
{
	// Getting the 3 indices of the triangle (local)
	uint indexOffset = triangle.indexOffset;
	ivec3 triangleIndex = ivec3(indices[nonuniformEXT(indexOffset + 0)],  //
	                          indices[nonuniformEXT(indexOffset + 1)],  //
	                          indices[nonuniformEXT(indexOffset + 2)]);
	triangleIndex += ivec3(triangle.vtxOffset);  // (global)

  	// Sample the triangle
  	mat4 worldFromInstance = matrices[triangle.matrixIndex];
  	const vec3 pos0 = (worldFromInstance * vec4(getVertex(triangleIndex.x), 1.0)).xyz;
  	const vec3 pos1 = (worldFromInstance * vec4(getVertex(triangleIndex.y), 1.0)).xyz;
  	const vec3 pos2 = (worldFromInstance * vec4(getVertex(triangleIndex.z), 1.0)).xyz;

  	vec3 scaledNormal = cross(pos1-pos0, pos2-pos0);
  	
  	triangleArea = sqrt(dot(scaledNormal, scaledNormal));
  	normal = normalize(scaledNormal);
  	x = sampleTriangle(seed, pos0, pos1, pos2);
}

vec3 triangleRIS(inout uint seed, in vec3 origin, in vec3 normal, in vec3 eye, in vec3 diffuse, in vec3 specular, float roughness)
{
	int numCandidates = max(1, pushC.numTrianglesM);
	float reservoirWeight = 0;
	vec3 sampleDir;
	float sampleDist2;

	// Sample candidates with probability proportional to radiant area
	for(int i = 0; i < numCandidates; ++i)
	{
		// Sample a random radiant point
		EmissiveTriangleInfo radiantTriangle = sampleTriangleWithAliasTable(seed); // P(t) = t.weightedRadiance;

		vec3 x, lightNormal;
		float triangleArea;
		uniformSampleTriangle(seed, radiantTriangle, x, lightNormal, triangleArea);

		// Compute target probability of the sample
		vec3 scaledDir = x-origin;
		float dist2 = dot(scaledDir, scaledDir);
		vec3 dir = normalize(scaledDir);
		float cosL = max(0, (dot(-dir, lightNormal)));
		float cosS = max(0, dot(dir, normal));
		float w = cosL*cosS*triangleArea/(dist2*radiantTriangle.weightedRadiance); // Candidate sample weight

		if(w == 0)
			continue;
		// Reservoir resampling
		reservoirWeight += w;
		if(rnd(seed) <= w/reservoirWeight)
		{
			sampleDir = dir;
			sampleDist2 = dist2;
		}
	}

	if(reservoirWeight == 0)
		return vec3(0.0);

	// Evaluate the sample f(x)/^p(x)
	float dist = sqrt(sampleDist2);
	traceRay(origin, sampleDir, dist+1e-3);
	if(prd.worldPos.w >= dist-1e-3)
	{
		// BRDF
		vec3 brdf = brdfModulation(normal,eye,sampleDir,diffuse,specular,roughness);
		return prd.emittance * brdf * reservoirWeight / numCandidates;
	}

	return vec3(0.0);
}

EmissiveTriangleInfo sampleTriangleTwoLevels(inout float reservoirWeight, inout float sampleWeight, inout int reservoirSize, inout LightInstanceInfo geometry, inout uint seed, in vec3 origin)
{
	EmissiveTriangleInfo result;

	
	{
		reservoirWeight = 0;
		sampleWeight = 0;
		reservoirSize = 0;
	}
	int numCandidates = max(1, pushC.numGeomSamplesM);
	float geomDist2;

	for(int i = 0; i < numCandidates; ++i)
	{
		// Choose an emissive mesh from the alias table
		float r = rnd(seed)*pushC.numLightInstances;
		uint bucket = uint(r);
		float p = r-bucket;
		AliasTable alias = lightAlias[nonuniformEXT(bucket)];
		uint emitterIndex = (p>alias.cutoff) ? alias.Ki : bucket;

		// Evaluate mesh distance
		LightInstanceInfo candidate = lightIstances[nonuniformEXT(emitterIndex)];
		mat4 worldFromCandidate = matrices[candidate.matrixIndex];
		vec3 meanPos = (worldFromCandidate*vec4(0,0,0,1)).xyz;
		float dist2 = dot(meanPos-origin, meanPos-origin);

		float w = 1/max(1e-2, dist2);
		if(w == 0)
			continue;

		reservoirWeight += w;

		if(rnd(seed) < w/reservoirWeight)
		{
			sampleWeight = w;
			geometry = candidate;
			geomDist2 = dist2;
		}
	}

	// Pick a triangle within the mesh
	result.indexOffset = (lcg(seed) % geometry.numTriangles)*3 + geometry.indexOffset;
	result.vtxOffset = geometry.vtxOffset;
	result.matrixIndex = geometry.matrixIndex;

	// Recompute the probability of sampling this triangle
	reservoirSize += numCandidates;
	float p_geom = geometry.weightedRadiance * sampleWeight * reservoirSize / (reservoirWeight);
	result.weightedRadiance = p_geom / geometry.numTriangles;

	return result;
}

vec3 twoLevelRIS(inout uint seed, in vec3 origin, in vec3 normal, in vec3 eye, in vec3 diffuse, in vec3 specular, float roughness)
{
	int numCandidates = max(1, pushC.numTrianglesM);
	float reservoirWeight = 0;
	vec3 sampleDir;
	float sampleDist2;

	float geometryReservoir = 0;
	float geometrySample = 0;
	int geometryReservoirSize = 0;
	LightInstanceInfo geometry;

	// Sample candidates with probability proportional to radiant area
	for(int i = 0; i < numCandidates; ++i)
	{
		// Sample a random radiant point
		EmissiveTriangleInfo radiantTriangle = sampleTriangleTwoLevels(geometryReservoir, geometrySample, geometryReservoirSize, geometry, seed, origin); // P(t) = t.weightedRadiance;

		vec3 x, lightNormal;
		float triangleArea;
		uniformSampleTriangle(seed, radiantTriangle, x, lightNormal, triangleArea);

		// Compute target probability of the sample
		vec3 scaledDir = x-origin;
		float dist2 = dot(scaledDir, scaledDir);
		vec3 dir = normalize(scaledDir);
		float cosL = max(0, (dot(-dir, lightNormal)));
		float cosS = max(0, dot(dir, normal));

		float w = cosL*cosS*triangleArea/(dist2*radiantTriangle.weightedRadiance); // Candidate sample weight

		if(w == 0)
			continue;
		// Reservoir resampling
		reservoirWeight += w;
		if(rnd(seed) <= w/reservoirWeight)
		{
			sampleDir = dir;
			sampleDist2 = dist2;
		}
	}

	if(reservoirWeight == 0)
		return vec3(0.0);

	// Evaluate the sample f(x)/^p(x)
	float dist = sqrt(sampleDist2);
	traceRay(origin, sampleDir, dist+1e-3);
	if(prd.worldPos.w >= dist-1e-3)
	{
		// BRDF
		vec3 brdf = brdfModulation(normal,eye,sampleDir,diffuse,specular,roughness);
		return prd.emittance * brdf * reservoirWeight / numCandidates;
	}

	return vec3(0.0);
}

vec3 explicitLightSampling(inout uint seed, in vec3 origin, in vec3 normal, in vec3 eye, in vec3 diffuse, in vec3 specular, float roughness)
{
	if(renderFlag(FLAG_EMIS_TRIS))
	{
		return triangleRIS(seed, origin, normal, eye, diffuse, specular, roughness);
	}
	else
	{
		return twoLevelRIS(seed, origin, normal, eye, diffuse, specular, roughness);
	}
}

void main()
{
	// Initialize the random number
	uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int(clockARB()));

	const vec2 pixelOffset = renderFlag(FLAG_JITTER_AA) ? vec2(rnd(seed), rnd(seed)) : vec2(0.5);
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + pixelOffset;
	const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
	vec2       d           = inUV * 2.0 - 1.0;

	const bool nextEventEstimation = renderFlag(FLAG_NEXT_EE);
	vec3 rayAccumLight = vec3(0);

	for(int i = 0; i < pushC.numPathsPerPixel; ++i)
	{
		vec4 origin    = cam.viewInverse * vec4(0, 0, 0, 1);
		vec4 target    = cam.projInverse * vec4(d.x, d.y, 1, 1);
		vec4 direction = cam.viewInverse * vec4(normalize(target.xyz), 0);

		if(renderFlag(FLAG_DOF))
		{
			vec4 viewSpaceLensSample = vec4(sampleDisk(seed, pushC.lensRadius) * vec2(1.0, float(gl_LaunchSizeEXT.x)/gl_LaunchSizeEXT.y), 0, 1);
			origin = cam.viewInverse * viewSpaceLensSample;

			direction = cam.viewInverse * vec4(normalize(target.xyz*pushC.focalDistance-viewSpaceLensSample.xyz), 0);
		}

		vec3 lightModulation = vec3(1);
		int maxDepth = nextEventEstimation ? pushC.maxBounces : (pushC.maxBounces+1);
		for(int rayDepth = 0; rayDepth < maxDepth; rayDepth++)
		{
			if(!traceRay(origin.xyz, direction.xyz)) // Miss
			{
				rayAccumLight += pushC.clearColor.xyz * lightModulation;
				break;
			}
			// --- Process hit ---
			// Emissive
			if(prd.emittance != vec3(0.0))
			{
				if(!nextEventEstimation || rayDepth == 0)
					rayAccumLight += prd.emittance * lightModulation;
				break; // Terminate ray early on emissive surfaces
			}

			// Prepare next bounce
			vec3 hitNormal = prd.worldNormal;
			vec3 tangent, bitangent;
			createCoordinateSystem(hitNormal, tangent, bitangent);
			vec3 diffuseColor = prd.baseColor.xyz * (1-prd.metallic);
			vec3 specColor = mix(vec3(0.04),prd.baseColor.xyz,prd.metallic);
		
			origin.xyz = prd.worldPos.xyz + hitNormal * max(1e-5, 1e-6 * prd.worldPos.w);

			// Explicit light sampling
			vec3 eye = -direction.xyz;
			float roughness = prd.roughness;
			if(nextEventEstimation)
			{
				rayAccumLight += lightModulation * explicitLightSampling(
					seed,
					origin.xyz,
					hitNormal,
					eye,
					diffuseColor,
					specColor,
					roughness);
			}

			// Next ray
			direction.xyz = samplingCosHemisphere(seed, tangent, bitangent, hitNormal);
			lightModulation *= brdfModulation(hitNormal,eye,direction.xyz,diffuseColor,specColor,roughness);
		}
	}

	rayAccumLight = max(vec3(0), rayAccumLight) / pushC.numPathsPerPixel;

	// Do accumulation over time
	if(pushC.frame > 0)
	{
		float a         = 1.0f / float(pushC.frame + 1);
		vec3  old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
		imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color, rayAccumLight, a), 1.f));
	}
	else
	{
		// First frame, replace the value in the buffer
		imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(rayAccumLight, 1.f));
	}
}
