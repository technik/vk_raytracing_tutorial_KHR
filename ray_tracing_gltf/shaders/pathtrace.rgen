#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_shader_clock : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "binding.glsl"
#include "gltf.glsl"
#include "raycommon.glsl"
#include "sampling.glsl"

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1, rgba32f) uniform image2D image;
layout(set = 0, binding = 2) readonly buffer _InstanceInfo {PrimMeshInfo primInfo[];};

// For light sampling
layout(set = 1, binding = B_MATRICES) readonly buffer _Matrix { mat4 matrices[]; };
layout(set = 1, binding = B_LIGHT_INST) readonly buffer _LightInstance { LightInstanceInfo lightIstances[]; };
layout(set = 1, binding = B_LIGHT_TRIS) readonly buffer _EmissiveTriangle { EmissiveTriangleInfo emissiveTriangles[]; };
layout(set = 1, binding = B_TRI_ALIAS) readonly buffer _TriangleAlias { AliasTable triangleAlias[]; };
layout(set = 1, binding = B_LIGHT_ALIAS) readonly buffer _LightAlias { AliasTable lightAlias[]; };
layout(set = 1, binding = B_VERTICES) readonly buffer _VertexBuf {float vertices[];};
layout(set = 1, binding = B_INDICES) readonly buffer _Indices {uint indices[];};

layout(location = 0) rayPayloadEXT hitPayload prd;

layout(set = 1, binding = B_CAMERA) uniform CameraProperties
{
  mat4 view;
  mat4 proj;
  mat4 viewInverse;
  mat4 projInverse;
}
cam;

layout(push_constant) uniform Constants
{
    uint renderFlags;
    vec4  clearColor;
    int   frame;
    float lensRadius;
    float focalDistance;
    int maxBounces;
    int firstBounce;
    int numLightInstances;
    uint numEmissiveTriangles;
}
pushC;

bool renderFlag(uint flag)
{
	return (pushC.renderFlags & flag) > 0;
}

float D_GGX(float ndh, float a) {
    float k = a / max(1e-4, (ndh * ndh)*(a*a-1) + 1);
    return k * k / M_PI;
}

// Earl Hammon's Diffuse GGX talk
// Predivided by 4*ndl*ndv
float SmithGGX_G2Approx(float ndv, float ndl, float a)
{
    return 0.5 / mix(2*ndl*ndv, ndl+ndv, a);
}

// Actually returns G1/(2NdV) as it cancels out some terms in the VNDF estimator
float SmithGGXG1(float ndv, float alpha)
{
	float a2 = alpha*alpha;
	float num = 2*ndv;
	float den = ndv + sqrt(a2 + (1-a2)*ndv*ndv);
	return num / max(den,1e-6);
}

float SmithGGX_G2_over_G1(float ndv, float ndl, float alpha)
{
	float a2 = alpha*alpha;
	float den = ndv + sqrt(a2+(1-a2)*ndv*ndv);
	return den * 0.5 / mix(2*ndl*ndv, ndl+ndv, alpha);
}

vec3 F_Schlick(float hdl, vec3 f0) {
    float p = (1-hdl);
    float p2 = p*p;
    float p5 = p*p2*p2;
    return f0 + (1.0 - f0) * p5;
}

bool traceRay(in vec3 ro, in vec3 rd)
{
    uint  rayFlags = gl_RayFlagsOpaqueEXT;
    float tMax     = 10000.0;

  traceRayEXT(topLevelAS, // acceleration structure
        rayFlags,       // rayFlags
        0xFF,           // cullMask
        0,              // sbtRecordOffset
        0,              // sbtRecordStride
        0,              // missIndex
        ro,             // ray origin
        0.0,           // ray min range
        rd,           // ray direction
        tMax,           // ray max range
        0               // payload (location = 0)
      );

    return prd.worldPos.w >= 0;
}

bool traceRay(in vec3 ro, in vec3 rd, float maxT)
{
    uint  rayFlags = gl_RayFlagsOpaqueEXT;

  traceRayEXT(topLevelAS, // acceleration structure
        rayFlags,       // rayFlags
        0xFF,           // cullMask
        0,              // sbtRecordOffset
        0,              // sbtRecordStride
        0,              // missIndex
        ro,             // ray origin
        0.0,           // ray min range
        rd,           // ray direction
        maxT,           // ray max range
        0               // payload (location = 0)
      );

    return prd.worldPos.w >= 0;
}

// Return the vertex position
vec3 getVertex(uint index)
{
  vec3 vp;
  vp.x = vertices[3 * index + 0];
  vp.y = vertices[3 * index + 1];
  vp.z = vertices[3 * index + 2];
  return vp;
}

// No dot(n,l) included
vec3 brdfModulation(in vec3 normal, in vec3 eye, in vec3 light, in vec3 diff, in vec3 spec, float roughness)
{
	vec3 H = normalize(eye+light);
	float hdl = max(0,dot(H,light));
	float alpha = roughness*roughness;
	float ndl = max(0,dot(normal, light));
	float D = D_GGX(ndl, alpha);
	float ndv = max(0,dot(eye,normal));
	float V = SmithGGX_G2Approx(ndv, ndl, alpha);

	vec3 kS = F_Schlick(hdl, spec) * D * V;
	vec3 kD = diff / M_PI; // TODO: Proper energy conservation
	return kD + kS;
}

EmissiveTriangleInfo sampleTwoLevelLight(out float invPdf)
{
	EmissiveTriangleInfo result;

	// Choose an emissive mesh
	uint nLights = pushC.numLightInstances;
	uint emitterIndex;
	LightInstanceInfo lightInfo;
	if(renderFlag(FLAG_USE_ALIAS))
	{
		// Choose an alias
		float r = rnd(prd.seed)*nLights;
		uint bucket = uint(r);
		float p = r-bucket;
		AliasTable alias = lightAlias[nonuniformEXT(bucket)];
		uint emitterIndex = (p>alias.cutoff) ? alias.Ki : bucket;

		lightInfo = lightIstances[nonuniformEXT(emitterIndex)];
		invPdf = lightInfo.numTriangles / lightInfo.weightedRadiance;
	}
	else
	{
		emitterIndex = lcg(prd.seed) % nLights;
		lightInfo = lightIstances[nonuniformEXT(emitterIndex)];
		invPdf = nLights * lightInfo.numTriangles;
	}

	// Retrieve the Primitive mesh buffer information
	uint triNdx = lcg(prd.seed) % lightInfo.numTriangles;

	// Getting the 'first index' for this mesh (offset of the mesh + offset of the triangle)
	result.indexOffset = lightInfo.indexOffset + (3 * triNdx);
	result.vtxOffset = lightInfo.vtxOffset;           // Vertex offset as defined in glTF
	result.matrixIndex = lightInfo.matrixIndex;

	return result;
}

EmissiveTriangleInfo sampleEmissiveTris(out float invPdf)
{
	EmissiveTriangleInfo result;

	uint nLights = pushC.numEmissiveTriangles;
	if(renderFlag(FLAG_USE_ALIAS))
	{
		// Choose an alias
		float r = rnd(prd.seed)*nLights;
		uint bucket = uint(r);
		float p = r-bucket;
		AliasTable alias = triangleAlias[nonuniformEXT(bucket)];
		uint emitterIndex = (p>alias.cutoff) ? alias.Ki : bucket;
		result = emissiveTriangles[emitterIndex];
		invPdf = 1.f / result.weightedRadiance;
	}
	else
	{
		// Choose an emissive triangle
		invPdf = nLights;
		uint emitterIndex = lcg(prd.seed) % nLights;
		result = emissiveTriangles[emitterIndex];
	}

	return result;
}

vec3 explicitLightSampling(in vec3 origin, in vec3 normal, in vec3 eye, in vec3 diffuse, in vec3 specular, float roughness)
{
	// Choose a triangle
	float invPDF = 1;
	EmissiveTriangleInfo lightInfo;
	if(renderFlag(FLAG_EMIS_TRIS))
	{
		lightInfo = sampleEmissiveTris(invPDF);
	}
	else
	{
		lightInfo = sampleTwoLevelLight(invPDF);
	}

	// Getting the 3 indices of the triangle (local)
	uint indexOffset = lightInfo.indexOffset;
	ivec3 triangleIndex = ivec3(indices[nonuniformEXT(indexOffset + 0)],  //
	                          indices[nonuniformEXT(indexOffset + 1)],  //
	                          indices[nonuniformEXT(indexOffset + 2)]);
	triangleIndex += ivec3(lightInfo.vtxOffset);  // (global)

  	// Sample the triangle
  	mat4 worldFromInstance = matrices[lightInfo.matrixIndex];
  	const vec3 pos0 = (worldFromInstance * vec4(getVertex(triangleIndex.x), 1.0)).xyz;
  	const vec3 pos1 = (worldFromInstance * vec4(getVertex(triangleIndex.y), 1.0)).xyz;
  	const vec3 pos2 = (worldFromInstance * vec4(getVertex(triangleIndex.z), 1.0)).xyz;
  	vec3 vtxPos = sampleTriangle(prd.seed, pos0, pos1, pos2);

	vec3 target = vtxPos.xyz;
	vec3 dir = target - origin;
	if(dot(dir,normal) <= 0)
	{
		return vec3(0);
	}
	
	float dist2 = dot(dir,dir);
	float dist = sqrt(dist2);
	
	dir = normalize(dir);
	traceRay(origin, dir, dist+1e-3);
	if(prd.worldPos.w >= dist-1e-3)
	{
		vec3 lightNormal = cross(pos2-pos0, pos1-pos0);
		float triangleArea = sqrt(dot(lightNormal,lightNormal))/2;
		float ndl = dot(dir, normal);
		// BRDF
		vec3 brdf = brdfModulation(normal,eye,dir,diffuse,specular,roughness) * ndl;
		return prd.emittance * brdf * vec3(triangleArea * invPDF / dist2 * max(0,dot(normalize(lightNormal),dir)));
	}
	
	return vec3(0);
}

void main()
{
	// Initialize the random number
	prd.seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int(clockARB()));

	const vec2 pixelOffset = renderFlag(FLAG_JITTER_AA) ? vec2(rnd(prd.seed), rnd(prd.seed)) : vec2(0.5);
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + pixelOffset;
	const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
	vec2       d           = inUV * 2.0 - 1.0;

	vec4 origin    = cam.viewInverse * vec4(0, 0, 0, 1);
	vec4 target    = cam.projInverse * vec4(d.x, d.y, 1, 1);
	vec4 direction = cam.viewInverse * vec4(normalize(target.xyz), 0);

	if(renderFlag(FLAG_DOF))
	{
		vec4 viewSpaceLensSample = vec4(sampleDisk(prd.seed, pushC.lensRadius) * vec2(1.0, float(gl_LaunchSizeEXT.x)/gl_LaunchSizeEXT.y), 0, 1);
		origin = cam.viewInverse * viewSpaceLensSample;

		direction = cam.viewInverse * vec4(normalize(target.xyz*pushC.focalDistance-viewSpaceLensSample.xyz), 0);
	}

	vec3 lightModulation = vec3(1);
	vec3 rayAccumLight = vec3(0);

	const bool nextEventEstimation = renderFlag(FLAG_NEXT_EE);

	int maxDepth = nextEventEstimation ? pushC.maxBounces : (pushC.maxBounces+1);
	for(int rayDepth = 0; rayDepth < maxDepth; rayDepth++)
	{
		if(!traceRay(origin.xyz, direction.xyz)) // Miss
		{
			rayAccumLight += pushC.clearColor.xyz * lightModulation;
			break;
		}
		// --- Process hit ---
		// Emissive
		if(prd.emittance != vec3(0.0))
		{
			if(!nextEventEstimation || rayDepth == 0)
				rayAccumLight += prd.emittance * lightModulation;
			break; // Terminate ray early on emissive surfaces
		}

		// Prepare next bounce
		vec3 hitNormal = prd.worldNormal;
		vec3 tangent, bitangent;
		createCoordinateSystem(hitNormal, tangent, bitangent);
		vec3 diffuseColor = prd.baseColor.xyz * (1-prd.metallic);
		vec3 specColor = mix(vec3(0.04),prd.baseColor.xyz,prd.metallic);
	
		// Next
		origin.xyz = prd.worldPos.xyz + hitNormal * max(1e-6, 1e-6 * prd.worldPos.w);

		// Explicit light sampling
		vec3 eye = -direction.xyz;
		float roughness = prd.roughness;
		if(nextEventEstimation)
		{
			rayAccumLight += lightModulation * explicitLightSampling(
				origin.xyz,
				hitNormal,
				eye,
				diffuseColor,
				specColor,
				roughness);
		}

		// Next ray
		direction.xyz = samplingCosHemisphere(prd.seed, tangent, bitangent, hitNormal);
		lightModulation *= brdfModulation(hitNormal,eye,direction.xyz,diffuseColor,specColor,roughness);
	}

	rayAccumLight = max(vec3(0), rayAccumLight);

	// Do accumulation over time
	if(pushC.frame > 0)
	{
		float a         = 1.0f / float(pushC.frame + 1);
		vec3  old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
		imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color, rayAccumLight, a), 1.f));
	}
	else
	{
		// First frame, replace the value in the buffer
		imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(rayAccumLight, 1.f));
	}
}
